target$species<-rownames(target)
target<-melt(target,id.vars = "species")
colnames(target)<-c("species","fleet","target")
Bio2<-merge(Bio2, target)
Bio2<-split(Bio2, Bio2$fleet)
# merge info biomass level, ref points and target spp
Bio<-merge(Bio,target)
Bio$timestep<-i_time
Bio<-split(Bio, Bio$fleet)
Bio<-lapply(Bio, function(x) x[-which(x$target == 0 | x$bioStatus =="Above"),])
# output this info
BioOut<-do.call("rbind",Bio) %>%
select(-c(target, bioStatus))
rownames(BioOut)<-NULL
# calcualte effort of each fleet for the next time step and based on profits maximisation: whether effort is allowed change based on profits or forced to stabilise or decrease is based on biomass treshold.
for(i in 1:length(Bio)){
# i = 3
# try with no seriorella - check the decreases in effort and how it it weighted:
# with seriorella (without the fix), decreases in effort is 0.07508566
# without seriorella (with the fix), decreases in effort is 0.1636155 - Bigger!
# BioOut<-BioOut %>% filter(species != "seriolella punctata")
# calcualte how many species reached tresholds for each fleet
SpBelowLimits<-split(BioOut, BioOut$fleet)
SpBelowLimits<-SpBelowLimits[[i]]
n20<-SpBelowLimits[SpBelowLimits$bioLim == "bio20check",]
n20<-nrow(n20)
n40<-SpBelowLimits[SpBelowLimits$bioLim == "bio40check",]
n40<-nrow(n40)
n48<-SpBelowLimits[SpBelowLimits$bioLim == "bio48check",]
n48<-nrow(n48)
# calcualte by how much each spp is below msy tresholds
Perc40<-SpBelowLimits[SpBelowLimits$bioLim == "bio40check",]
Perc40<-merge(Perc40,Bio2[[i]], all = FALSE)
# % of decrease in species abundance
Perc40$Perc40<-((Perc40$bio40-Perc40$bioLevel)/Perc40$bio40)
# % of decrease in effort
# option A - weighted sum of contributing species: (a*Ba + b*Bb + c*Bc)/(Ba + Bb + Bc)
# contribution to the community
Perc40$contribution<-Perc40$bioLevel*Perc40$Perc40
# contribution to the catch # this can be added to slow decreases
Perc40$contribution<-Perc40$contribution*Perc40$target # to comment
# MeanPerc40A<-sum(Perc40$contribution)/sum(Perc40$bioLevel) # problem: less species below target result in lower biolevel (less spp = less abundance) and higher decrease in effort. # to comment
# instead: consider sum of biomass in the whole commuity. decreases in effort are too low as here you are considering all spp so dividing by a huge number
# MeanPerc40A<-sum(Perc40$contribution)/sum(Blevel$bioLevel)
# instead: consider sum of biomass of the species that are target of the fisheriy? (basically this needs to be a fixed quantity across the runs as it's the reference level)
ref<-Bio2[[i]] %>% filter(target>0.005) # consider only target and bycatch # to uncomment
# # ref$bioLevel<-ref$bioLevel*ref$target # wait for their importance as target spp
MeanPerc40A<-sum(Perc40$contribution)/sum(ref$bioLevel)
# MeanPerc40A<-MeanPerc40A*0.05 # this is to speed/slow decreases in effort up instead of using a cut bigger than 0 on ref.
# option B - cube root of (a * b * c)
# MeanPerc40B<-prod(Perc40$Perc40)^(1/3)
# option C - simple mean
# MeanPerc40C<-mean(Perc40$Perc40)
if(n48<5 & n40==0 & n20==0) # if all these conditions are true at the same time effort changes accoring to profits
{
# print("all good")
Effort_itime_change[i]<-ke[i,"ke"]*(profit_itime[[i]])
Effort_itime_next[i]<-effortOut_dt[i_time,][i] + (Effort_itime_change[[i]] * dt)
}else if(n48>=5 & n40==0 & n20==0){ # if more than 5 spp are  below 48 but above 40 and 20 ....
# if fishing is profitable, do not allow any increase in effort
if(profit_itime[[i]]>0) {
Effort_itime_change[i]<-0
Effort_itime_next[i]<-effortOut_dt[i_time,][i] + (Effort_itime_change[[i]] * dt)
# if fishing is not profitable and it is decreasing, let it decrease according to profits
}else{
Effort_itime_change[i]<-ke[i,"ke"]*(profit_itime[[i]])
Effort_itime_next[i]<-effortOut_dt[i_time,][i] + (Effort_itime_change[[i]] * dt)
}
}else if(n40!=0 & n20<5){
# if some speceis is below 40 and less then 5 spp are below 20 descrease effort
# new effort according to profits
test = effortOut_dt[i_time,][i] + (ke[i,"ke"]*(profit_itime[[i]]) * dt)
# new effort according to management
test2 = effortOut_dt[i_time,][i] * (1 - MeanPerc40A*dt)
# if fishing is not profitable and it is decreasing more than how it would decrease according to management, let it decrease according to profits
if(profit_itime[[i]]<= 0 & test < test2){
Effort_itime_change[i]<-ke[i,"ke"]*(profit_itime[[i]])
Effort_itime_next[i]<-effortOut_dt[i_time,][i] + (Effort_itime_change[[i]] * dt)
# if fishing is profitable or decreasesin effort according to profits are small, force a descrease in effort proportional to the decrease in biomass below tresholds. the old version only had this.
}else{
Effort_itime_change[i]<-NA
Effort_itime_next[i]<-effortOut_dt[i_time,][i] * (1 - MeanPerc40A*dt)
}
}else{
# if more than 5 speceis are below 20% stop the fishery
Effort_itime_change[i]<-0
Effort_itime_next[i]<-0
}
names(Effort_itime_change)[i]<-fleet[i]
names(Effort_itime_next)[i]<-fleet[i]
Effort_itime_next[[i]]<-ifelse(is.na(Effort_itime_next[[i]]) | Effort_itime_next[[i]]<0 | is.infinite(Effort_itime_next[[i]]),0, Effort_itime_next[[i]])
} # end of for loop
}else{ # start of management = FALSE
for(i in 1:length(fleet)){
# i = 3
# profit_itime[[i]]
# effortOut_dt[i_time,][i]
# profit_itime[[i]]*areaEco
# effortOut_dt[i_time,][i]*areaEco
Effort_itime_change[i]<-ke[i,"ke"]*(profit_itime[[i]])
Effort_itime_next[i]<-effortOut_dt[i_time,][i] + (Effort_itime_change[[i]] * dt)
names(Effort_itime_change)[i]<-fleet[i]
names(Effort_itime_next)[i]<-fleet[i]
Effort_itime_next[[i]]<-ifelse(is.na(Effort_itime_next[[i]]) | Effort_itime_next[[i]]<0 | is.infinite(Effort_itime_next[[i]]),0, Effort_itime_next[[i]])
} # end of for loop
} # end of managemetn = FALSE
# change format of effort
Effort_itime_change<-t(do.call("rbind", Effort_itime_change))
Effort_itime_next<-t(do.call("rbind", Effort_itime_next))
# update effort for next time step
effortOut_dt[i_time+1, ]<-Effort_itime_next
# # but if the fishery has been inactive for the previous e.g. 4 runs, and effort is sill negative or zero, then set effort for next time step to a minimum value to allow for a fleet to start fishing again. this time depends on dt (if dt=0.25 fishing restarts every 2 years)
# # need to test this...
nYear = 4
back <- seq(i_time, i_time-(nYear/dt)) # from i_time to 4 years back
if(i_time > (nYear/dt)){
for(i in 1:length(fleet)){
effortOut_dt[i_time+1, i]<- ifelse(sum(sum(effortOut_dt[back[1]:back[length(back)],i]),Effort_itime_next[[i]]) <= 0, 0.01, Effort_itime_next[[i]])
}}
# yield, revenue and profits in df format - important when saving these data below
yield_dt[i_time,,,]<-yield_itime
revenue_dt[i_time,]<-revenue_itime_tot
profit_dt[i_time,]<-profit_itime
F_dt[i_time,,,]<-F_itime
}else if(multiFleet==TRUE){
yield_itime <-sweep(F_itime,c(1,2), B_itime, "*")
} # end of fleetDynamics = TRUE or multiFleet == TRUE
# Store results only every t_step steps.
store <- t_dimnames_index %in% (i_time + 1)
if (any(store)) {
# Advance progress bar
# CN you can turn off bar when running calibration
# pb$tick()
# if (hasArg(shiny_progress)) {
#   shiny_progress$inc(amount = proginc)
# }
# Store result
sim@n[which(store), , ] <- n
sim@n_pp[which(store), ] <- n_pp
sim@n_bb[which(store), ] <- n_bb
sim@n_aa[which(store), ] <- n_aa
# CN store fleetDynamics results
if(fleetDynamics == TRUE){
# sim@effort
sim@effortOut[which(store), ] <- effortOut_dt[i_time,]
sim@yield[which(store),,,] <- yield_itime
sim@revenue[which(store), ] <- revenue_itime_tot
sim@profit[which(store), ] <- profit_itime
sim@F[which(store),,,] <- F_itime
if (management == TRUE){
# info on declining spp
# stop for calibration
sim@BioOut[[i_time]]<-BioOut
# info on Biological limits for each species
sim@BioLimits[[i_time]]<-Bio2
}
# add values for time step 1. this is because n, n_pp etc and effort are initialised above (before the loop) while these parameters at time step = 1 are calcualted withing the loop. The loop saves from time step 2 leaving 1 at initial values.
sim@yield[1,,,]<-yield_dt[1,,,]
sim@revenue[1,]<-revenue_dt[1,]
sim@profit[1,]<-profit_dt[1,]
sim@F[1,,,] <-F_dt[1,,,]
}else if (multiFleet==TRUE){
sim@yield[which(store),,,] <- yield_itime
sim@yield[1,,,]<-yield_dt[1,,,]
}
}
} # end of for loop
plotFleet(sim)
rm(list=ls())
library(tidyverse)
library(devtools)
library(plyr)
library(Rcpp) # this will allow you to run the inner_project_loop
library(reshape2)
library(inline)
library(ggplot2)
library(vegan)
# install.packages("shiny")
# library(mizer) # if inner_loop error, you need to upload mizer
library(shiny)
library("purrr")
library("dplyr")
setwd("/Users/nov017/R-projects/Mizer-fleet/R")
source("data.R")
source("help.R")
source("MizerParams-class.R")
source("MizerSim-class.R")
source("plots.R")
source("project_methods.R")
source("project.R")
source("RcppExports.R")
source("selectivity_funcs.R")
source("summary_methods.R")
source("wrapper_functions.R")
source("DataFunction.R")
# load data
# load("/Users/nov017/Dropbox/Mizer-fleet/R/model/FDData_Nov.RData") # FDData_opn3.RData or FDData_opn2.RData (was FDData_Nov.RData)
# new folder
load("/Users/nov017/Dropbox/Mizer-fleet_extension/data/FDData_opn3_May.RData")
# not sure I should specify this here?
sim = sim_FD_bmsy
df_param = df_param2
interaction = theta
kappa = kappa
kappa_ben = kappa_ben
kappa_alg = kappa_alg
w_pp_cutoff = w_pp_cutoff
min_w_bb = min_w_bb
w_bb_cutoff = w_bb_cutoff
fleetDynamics = TRUE
selectivity_params = df_selParam_new
catchability = df_target_bmsy2
target = df_target_bmsy2
effort = 0
dt = 0.25
management = TRUE
price = df_price_new
cost = df_cost3
diet_steps = 0
ke = ke_fleet
scaling_price = scaling_price
Blevel_management = "Bmsy"
initial_n = initial_n
initial_n_pp = initial_n_pp
initial_n_bb = initial_n_bb
initial_effort = initial_effort2
```
#-----------------------------------------
# fleet strucutres and scenarios
#----------------------------------------------
```{r}
######## Scenario: initial caommunity as per last time step of time-variant community. Run forward using price and costs as per last time step of time-variant community, but changing interaction matrix as per scenarios.
####### initial community
initial_n_scenario = sim@n[nrow(sim@n),,]
initial_n_pp_scenario  = sim@n_pp[nrow(sim@n_pp),]
initial_n_bb_scenario  = sim@n_bb[nrow(sim@n_bb),]
initial_effort_scenario = sim@effortOut[dim(sim@effortOut)[1],]
####### forward price and costs
t_max = 23 # till 2030 or 2050? if you run it for too long it's going to collaps...
price_forward = t(replicate(t_max, price[nrow(price),]))
rownames(price_forward)<-seq(1:t_max) # or...
rownames(price_forward)<-seq(2018,(2018+t_max-1))
cost_forward1 <- t(replicate(t_max, cost[nrow(cost),,1]))
rownames(cost_forward1)<-seq(1:t_max) # or ...
rownames(cost_forward1)<-seq(2018,(2018+t_max-1))
cost_forward2 <- t(replicate(t_max, cost[nrow(cost),,2]))
rownames(cost_forward2)<-seq(1:t_max) # or ...
rownames(cost_forward2)<-seq(2018,(2018+t_max-1))
cost_forward <-array(c(cost_forward1,cost_forward2), dim = c(t_max,dim(cost)[2],dim(cost)[3])) # or ...
cost_forward <-array(c(cost_forward1,cost_forward2),dim = c(dim(cost_forward1)[1],dim(cost)[2],dim(cost)[3]), dimnames = c(dimnames(cost_forward1)[1],dimnames(cost)[2],dimnames(cost)[3]))
####### TRIAL changes in Bmsy fro platy and genypt - this is done in SEAmodel if you decide to go this way
df_param2<-df_param
# df_param2[9, "Bmsy"]<-0 #df_param2[9, "Bmsy"]*0.001
# df_param2[16, "Bmsy"]<-0 #df_param2[16, "Bmsy"]*0.0001
params_trial <- MizerParams(df_param2, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=TRUE, selectivity_params = selectivity_params, catchability = catchability, target = target)
sim_trial <- project(params_trial, effort = 0, dt = dt, fleetDynamics = TRUE, management = TRUE, multiFleet = FALSE, price = price_forward, cost = cost_forward, diet_steps = 0, ke = ke, initial_effort = initial_effort_scenario, scaling_price = scaling_price, Blevel_management = Blevel_management, initial_n = initial_n_scenario, initial_n_pp = initial_n_pp_scenario , initial_n_bb = initial_n_bb_scenario)
plotFleet(sim_trial)
params_trial <- MizerParams(df_param2, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=TRUE, selectivity_params = selectivity_params, catchability = df_target_NoCompetition, target = df_target_NoCompetition)
sim_trial <- project(params_trial, effort = 0, dt = 0.25, fleetDynamics = TRUE, management = TRUE, multiFleet = FALSE, price = price_forward, cost = cost_forward, diet_steps = 0, ke = ke, initial_effort = initial_effort_scenario, scaling_price = scaling_price, Blevel_management = Blevel_management, initial_n = initial_n_scenario, initial_n_pp = initial_n_pp_scenario, initial_n_bb = initial_n_bb_scenario, initial_n_aa = params_trial@initial_n_aa,t_save = 1, t_max = 13,temperature = rep(params_trial@t_ref, times = t_max),shiny_progress = NULL)
plotFleet(sim_trial)
# trial
rm(list=ls())
library(tidyverse)
library(devtools)
library(plyr)
library(Rcpp) # this will allow you to run the inner_project_loop
library(reshape2)
library(inline)
library(ggplot2)
library(vegan)
# install.packages("shiny")
# library(mizer) # if inner_loop error, you need to upload mizer
library(shiny)
library("purrr")
library("dplyr")
setwd("/Users/nov017/R-projects/Mizer-fleet/R")
source("data.R")
source("help.R")
source("MizerParams-class.R")
source("MizerSim-class.R")
source("plots.R")
source("project_methods.R")
source("project.R")
source("RcppExports.R")
source("selectivity_funcs.R")
source("summary_methods.R")
source("wrapper_functions.R")
source("DataFunction.R")
# load data
# load("/Users/nov017/Dropbox/Mizer-fleet/R/model/FDData_Nov.RData") # FDData_opn3.RData or FDData_opn2.RData (was FDData_Nov.RData)
# new folder
load("/Users/nov017/Dropbox/Mizer-fleet_extension/data/FDData_opn3_May.RData")
# not sure I should specify this here?
sim = sim_FD_bmsy
df_param = df_param2
interaction = theta
kappa = kappa
kappa_ben = kappa_ben
kappa_alg = kappa_alg
w_pp_cutoff = w_pp_cutoff
min_w_bb = min_w_bb
w_bb_cutoff = w_bb_cutoff
fleetDynamics = TRUE
selectivity_params = df_selParam_new
catchability = df_target_bmsy2
target = df_target_bmsy2
effort = 0
dt = 0.25
management = TRUE
price = df_price_new
cost = df_cost3
diet_steps = 0
ke = ke_fleet
scaling_price = scaling_price
Blevel_management = "Bmsy"
initial_n = initial_n
initial_n_pp = initial_n_pp
initial_n_bb = initial_n_bb
initial_effort = initial_effort2
```
#-----------------------------------------
# fleet strucutres and scenarios
#----------------------------------------------
```{r}
######## Scenario: initial caommunity as per last time step of time-variant community. Run forward using price and costs as per last time step of time-variant community, but changing interaction matrix as per scenarios.
####### initial community
initial_n_scenario = sim@n[nrow(sim@n),,]
initial_n_pp_scenario  = sim@n_pp[nrow(sim@n_pp),]
initial_n_bb_scenario  = sim@n_bb[nrow(sim@n_bb),]
initial_effort_scenario = sim@effortOut[dim(sim@effortOut)[1],]
####### forward price and costs
t_max = 23 # till 2030 (13) or 2040 (23)? if you run it for too long it's going to collaps...
price_forward = t(replicate(t_max, price[nrow(price),]))
rownames(price_forward)<-seq(1:t_max) # or...
rownames(price_forward)<-seq(2018,(2018+t_max-1))
cost_forward1 <- t(replicate(t_max, cost[nrow(cost),,1]))
rownames(cost_forward1)<-seq(1:t_max) # or ...
rownames(cost_forward1)<-seq(2018,(2018+t_max-1))
cost_forward2 <- t(replicate(t_max, cost[nrow(cost),,2]))
rownames(cost_forward2)<-seq(1:t_max) # or ...
rownames(cost_forward2)<-seq(2018,(2018+t_max-1))
cost_forward <-array(c(cost_forward1,cost_forward2), dim = c(t_max,dim(cost)[2],dim(cost)[3])) # or ...
cost_forward <-array(c(cost_forward1,cost_forward2),dim = c(dim(cost_forward1)[1],dim(cost)[2],dim(cost)[3]), dimnames = c(dimnames(cost_forward1)[1],dimnames(cost)[2],dimnames(cost)[3]))
####### TRIAL changes in Bmsy fro platy and genypt - this is done in SEAmodel if you decide to go this way
df_param2<-df_param
# df_param2[9, "Bmsy"]<-0 #df_param2[9, "Bmsy"]*0.001
# df_param2[16, "Bmsy"]<-0 #df_param2[16, "Bmsy"]*0.0001
####### interaction matrix options
######## note - be carefull with these values, does this mean that exploitation rate is higher than 1? the values below act as catchability only, but if you add all the Fmort from all the fleets? check that exploitation rate (catch/biomass at t) is lower than 1
# colSums(df_target_bmsy2*initial_effort2)
#
# # or model output...
#
# a<-getBiomass(sim)
# b<-sim@yield
# b<-rowSums(aperm(b,c(1,2,4,3)),dims=3) # sum over size
# b<-rowSums(b,dims=2)
# c<-b/a
# c[c>0.2] # exploitation rate for all spp is less than 20%
######## trial model to understand things - status quo (initial community and fleets as per sim_FD_bmsy)
params_trial <- MizerParams(df_param2, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=TRUE, selectivity_params = selectivity_params, catchability = catchability, target = target)
sim_trial <- project(params_trial, effort = 0, dt = dt, fleetDynamics = TRUE, management = TRUE, multiFleet = FALSE, price = price_forward, cost = cost_forward, diet_steps = 0, ke = ke, initial_effort = initial_effort_scenario, scaling_price = scaling_price, Blevel_management = Blevel_management, initial_n = initial_n_scenario, initial_n_pp = initial_n_pp_scenario , initial_n_bb = initial_n_bb_scenario)
plotFleet(sim_trial)
sim_trial@effortOut
df_target_unfished<-target
df_target_unfished[]<-0
library(matrixStats)
df_target_NoCompetition<-target
trial<-colMaxs(df_target_NoCompetition)
trial<-trial[-which(trial == 0)]
df_target_NoCompetition[df_target_NoCompetition %in% trial]<-1
df_target_NoCompetition[df_target_NoCompetition != 1]<-0
div<-colSums(df_target_NoCompetition*initial_effort_scenario)/colSums(target*initial_effort_scenario)
df_target_NoCompetition<-sweep(df_target_NoCompetition, 2, div, FUN = '/')
df_target_NoCompetition[, "myctophids"]<-0
df_target_FullCompetition<-target
df_target_FullCompetition[]<-1
df_target_FullCompetition[, "myctophids"]<-0
div<-colSums(df_target_FullCompetition*initial_effort_scenario)/colSums(target*initial_effort_scenario)
df_target_FullCompetition<-sweep(df_target_FullCompetition, 2, div, FUN = '/')
df_target_FullCompetition[, "myctophids"]<-0
df_target_NoBycatch<-target
df<-target
for(i in 1:ncol(df)){
df<-df[order(df[,i]),]
df[c(1,2),i]<-0
}
df<-df[c(2,1,3,4,5),]
df_target_NoBycatch<-df
div<-colSums(df_target_NoBycatch*initial_effort_scenario)/colSums(target*initial_effort_scenario)
df_target_NoBycatch<-sweep(df_target_NoBycatch, 2, div, FUN = '/')
df_target_NoBycatch[, "myctophids"]<-0
colSums(df_target_NoBycatch*initial_effort_scenario)
colSums(target*initial_effort_scenario)
valuable<-sort(-df_price_new[nrow(df_price_new),])
valuable<-names(valuable)[1:6]
df_target_MoreTarget<-target
a<-colSums(target[,valuable]*initial_effort_scenario)
a<-a + (a*0.5) # plus 50% ?
div<-colSums(df_target_MoreTarget[,valuable]*initial_effort_scenario)/a
df_target_MoreTarget[,valuable]<-sweep(df_target_MoreTarget[,valuable], 2, div, FUN = '/')
colSums(df_target_MoreTarget*initial_effort_scenario)
colSums(target*initial_effort_scenario)
under<-c("macruronus novaezelandiae","nemadactylus macropterus","zeus faber","pristiophorus cirratus") # Jackass morwong is a bit funny as it's declining and there are no data for assessment. redfish?! recovery or undercaught? shawshrk is low values, not overfished
df_target_MoreUnderQuota<-target
a<-colSums(target[,under]*initial_effort_scenario)
a<-a + (a*0.5) # plus 50% ?
div<-colSums(df_target_MoreUnderQuota[,under]*initial_effort_scenario)/a
df_target_MoreUnderQuota[,under]<-sweep(df_target_MoreUnderQuota[,under], 2, div, FUN = '/')
colSums(df_target_MoreUnderQuota*initial_effort_scenario)
colSums(target*initial_effort_scenario)
target_scenario = list(unfished = df_target_unfished, noCompetition = df_target_NoCompetition, fullCompetition = df_target_FullCompetition, statusQuo = target, noBycatch = df_target_NoBycatch, MoreTarget = df_target_MoreTarget, MoreUnderQuota = df_target_MoreUnderQuota) # best = df_target_best)
params_scenario<-list()
sim_scenario<-list()
for(i in 1:length(target_scenario)){
# i = 4
params_scenario[[i]] <- MizerParams(df_param2,
interaction = theta,
kappa = kappa,
kappa_ben = kappa_ben,
kappa_alg = kappa_alg,
w_pp_cutoff = w_pp_cutoff,
min_w_bb = min_w_bb,
w_bb_cutoff = w_bb_cutoff,
fleetDynamics = TRUE,
selectivity_params = selectivity_params,
catchability = target_scenario[[i]],
target = target_scenario[[i]])
sim_scenario[[i]] <- project(params_scenario[[i]],
effort = 0,
dt = dt,
fleetDynamics = TRUE,
management = TRUE,
multiFleet = FALSE,
price = price_forward,
cost = cost_forward,
diet_steps = 0,
ke = ke,
initial_effort = initial_effort_scenario,
scaling_price = scaling_price,
Blevel_management = Blevel_management,
initial_n = initial_n_scenario,
initial_n_pp = initial_n_pp_scenario,
initial_n_bb = initial_n_bb_scenario)
names(sim_scenario)[i]<-names(target_scenario)[i]
}
plotFleet(sim_scenario$noCompetition) # declines in effort and yield despite increases in abundance - why? are declines driven by profits instead of management? when decreases are weigthed by contribution to cacthes they are multiplied by 1 instead of e.g. 0.01 and thus are bigger... (i.e. if a spp contributes a little than the decrease is small, if it contributes a lot - Q=1 - then decreases are bigger). this is the problem with SH, which is forced to steeply decrease because platy has a Q of 1 and is below 20. when platy recovers, changes in effort are less steep.
plotFleet(sim_scenario$fullCompetition) # collapses
plotFleet(sim_scenario$statusQuo) # some recoveries and increases
plotFleet(sim_scenario$noBycatch) # recoveries and increases in trends
plotFleet(sim_scenario$MoreTarget) # collapses
plotFleet(sim_scenario$MoreUnderQuota) # collapses
a<-sim_scenario$noCompetition
pr <- a@BioOut[[24]] %>%
filter(bioLim == "bio20check", fleet == "SET-SH")
unique(pr$species)
a@effortOut
a@profit
trial<-a@yield
trial<-rowSums(aperm(trial,c(1,2,4,3)),dims=3) # sum over size
trial<-as.data.frame.table(trial, responseName = "yield")
colnames(trial)<-c("year", "species","fleet", "yield")
trial<-trial%>%
left_join(df_param[,c(1,2)])
ggplot(trial,aes(x=year, y = yield, fill=species)) +
geom_bar(position = "stack", stat = "identity") +
theme_bw() +
facet_wrap(~fleet, scale = "free")
df_target_NoCompetition
ggplot(filter(trial,fleet == "SET-SH"),aes(x=year, y = yield, fill=species)) +
geom_bar(position = "stack", stat = "identity") +
theme_bw() +
facet_wrap(~fleet, scale = "free")
trial<-a@yield
trial<-rowSums(aperm(trial,c(1,2,4,3)),dims=3) # sum over size
trial<-as.data.frame.table(trial, responseName = "yield")
colnames(trial)<-c("year", "species","fleet", "yield")
trial<-trial%>%
left_join(df_param[,c(1,2)]) %>%
filter(fleet == "SET-SH")
ggplot(filter(trial),aes(x=year, y = yield, fill=species)) +
geom_bar(position = "stack", stat = "identity") +
theme_bw() +
facet_wrap(~fleet, scale = "free")
trial<-droplevels(trial)
ggplot(filter(trial),aes(x=year, y = yield, fill=species)) +
geom_bar(position = "stack", stat = "identity") +
theme_bw() +
facet_wrap(~fleet, scale = "free")
unique(trial$species)
trial
trial<-trial%>%
left_join(df_param[,c(1,2)]) %>%
filter(fleet == "SET-SH", yield >0)
ggplot(filter(trial),aes(x=year, y = yield, fill=species)) +
geom_bar(position = "stack", stat = "identity") +
theme_bw() +
facet_wrap(~fleet, scale = "free")
sim_scenario$unfished<-NULL
indi<-indicators(sim_scenario)
df_plot = indi$df_plot
a = c("statusQuo","noCompetition","fullCompetition","noBycatch","MoreTarget","MoreUnderQuota")
b = c("Status Quo","No Competition","Full Competition", "Less Bycatch","More Valuable","More Under-Quota")
col_values<-c("#08589e", "#2b8cbe", "#4eb3d3", "#7bccc4", "#a8ddb5", "#ccebc5", "#f0f9e8") # https://colorbrewer2.org/#type=sequential&scheme=Blues&n=7
plot_effort = plotFleetEffort(a,b, sim_scenario, sim_FD_bmsy, col_values[1:5])$plot_effort
plot_effort
plot_matrix = plotFleetMatrix(a,b,target_scenario, col_values[2])$plot_matrix
plot_bar_reduced = plotIndicators(a,b,df_plot, col_values[c(2,4)])$plot_bar_reduced # this one
plot_bar_reduced
library(patchwork)
plot_effort
plot_bar_reduced
