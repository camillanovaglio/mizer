# # R -> calibrate r_max
# # Q -> calibrate catchability
# # par_0<-par_0[-which(names(par_0) %in% c("optim_SEA_kappa_Cali","optim_SEA_kappa_SSB_Cali","optim_SEA_kappa_SSB"))]
# names(par_0)
#
# # delete previous runs
# par_0<-par_0[-which(names(par_0) %in% c("optim_SEA_kappa_Q_K_R_SECOND","optim_SEA_kappa_K_R_SECOND","optim_SEA_kappa_SSB_Q_K_R_FIRST","optim_SEA_kappa_SSB_K_R_FORTH", "optim_SEA_kappa_SSB_Q_K_SIXTH", "optim_SEA_kappa_K_R_SIXTH"))]
# names(par_0)
```
# analise results from calibration in pearcey *skip if already analysed MOVE TO FUNCTION!*
note - folders have been changed
```{r}
# plot_list = list()
# fit_list = list()
#
# for(i in 1:length(par_0)){
#
#   new_par<-par_0[[i]]
#
#   # kappa<-10^new_par[length(new_par)]
#   # r_max<-10^new_par[1:nrow(df_param)]
#   # Q<-10^new_par[(nrow(df_param)+1):(length(new_par)-1)]
#
#   # if calibration is on kappa_ben too...
#
#   kappa<-10^new_par[length(new_par)-1]
#   kappa_ben<-10^new_par[length(new_par)]
#   Q<-10^(new_par[(nrow(df_param)+1):(length(new_par)-2)])
#   r_max <- 10^(new_par[1:nrow(df_param)])
#
#   df_param$r_max<-r_max
#   df_param$catchability<-Q
#
#   params_calibration_test <- MizerParams(df_param, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=FALSE, selectivity_params = NA, catchability = NA, target = NA)
#
#   sim_calibration_test <- project(params_calibration_test, effort = constant_effort, dt = dt, fleetDynamics = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
#
#   yield_sim <- getYield(sim_calibration_test)
#   yield_sim <- yield_sim[dim(yield_sim)[1],]
#   df_y<-data.frame(calibrated = yield_sim, obs_y = Initialcomm@params@species_params$catchComm_t, species = names(yield_sim))
#   df_y<-df_y %>%
#     gather("option", "value", -species, -obs_y) %>%
#     `colnames<-`(c("observed", "species", "option", "modelled")) %>%
#     mutate(type = "YIELD",
#            species = df_param$spCommon)
#
#   fit_y<-summary(lm(modelled~ observed, df_y))$adj.r.squared
#
#   ssb_sim <- getSSB(sim_calibration_test)
#   ssb_sim <- ssb_sim[dim(ssb_sim)[1],]
#   df_ssb<-data.frame(calibrated = ssb_sim, obs_ssb = Initialcomm@params@species_params$ssbObs, species = names(ssb_sim))
#   df_ssb<-df_ssb %>%
#     gather("option", "value", -species, -obs_ssb) %>%
#     `colnames<-`(c("observed", "species", "option", "modelled")) %>%
#     mutate(type = "SSB",
#            species = df_param$spCommon)
#
#   fit_ssb<-summary(lm(modelled~ observed, df_ssb))$adj.r.square
#
#   rank_sim<-getBiomass(sim_calibration_test)
#   rank_sim<-rank_sim[dim(rank_sim)[1],]
#   rank_sim<-rank(-rank_sim)
#   df_rank<-data.frame(calibrated = rank_sim, obs_rank = Initialcomm@params@species_params$rankAb, species = names(rank_sim))
#   df_rank<-df_rank %>%
#     gather("option", "value", -species, -obs_rank) %>%
#     `colnames<-`(c("observed", "species", "option", "modelled")) %>%
#     mutate(type = "RANK",
#            species = df_param$spCommon)
#
#   fit_rank<-summary(lm(modelled~ observed, df_rank))$adj.r.squared
#
#   fit<-data.frame(y = fit_y, ssb = fit_ssb, rank = fit_rank)
#   fit_list[[i]]<-fit
#
#   df_plot_validation<-rbind(df_y, df_ssb, df_rank) %>%
#     mutate(type = paste(type, option))
#
#   # p<-ggplot(df_plot_validation, aes(x = log(observed), y = log(modelled), label = species))+
#   #   geom_point()+
#   #   geom_text()+
#   #   geom_smooth(method='lm',formula=y~x)+
#   #   geom_abline(intercept = 0, slope = 1)+
#   #   facet_wrap(~type, scale="free", ncol=2)
#   #
#   # plot_list[[i]]<-p
#   # names(plot_list)[i]<-names(par_0)[i]
#
# }
#
# fit_df<-do.call(rbind, fit_list) %>%
#   mutate(calibration = names(par_0))
#
# # extrapolate error too, but it may be smaller becasue you are using only 1 dataset...
# error<-do.call(rbind.data.frame,lapply(all_optim, function (x) x$value)) %>%
#   mutate(calibration = names(all_optim)) %>%
#   `colnames<-`(c("error", "calibration")) %>%
#   right_join(fit_df)
# error[which.min(error$error),]
#
# # # Save plots to tiff. Makes a separate file for each plot.
# # setwd("/Users/nov017/Dropbox/Mizer-fleet/plot/calibration")
# # for (i in 1:length(plot_list)) {
# #     file_name = paste( names(plot_comm_list)[i], ".tiff", sep="")
# #     tiff(file_name, height=8, width=8, units ='in', res=300)
# #     print(plot_list[[i]])
# #     dev.off()
# # }
```
# PROBLEM
there is a problem in running these 'generalised calibrations': e.g. if R=FALSE, optim will pick values for this parameters because this param is in logParams (vactors of param to be calibrated), but new R values won't be incorportated in df_param and tested becasue we are not interested in calibrating them (i.e R+FALSE). So, these will be accounted as calibration trials, but parameters considered in df_param won't change and so the error won't change. These are 'empty runs' that optim may interpret as 'nothing is changing' so the error is minimised. Does it happen in reaslity? check results...
#-----------------------------------------
# final calibrated community *need to run*
#----------------------------------------------
```{r}
# # choosing according to highiest fir_df
# fit_df$sum<-fit_df$y+fit_df$ssb+fit_df$rank
# fit_df[,c("calibration","y","ssb","rank","sum")]
# fit_df[,c("calibration", "y", "ssb","rank","sum")]
# fit_df[which.max(fit_df$sum),]
setwd("/Users/nov017/Dropbox/Mizer-fleet_extension/calibration_server/data")
# * see calibration trials in plot/calibrationTrial.doc
# FIRST
# optim_SEA_kappa_SSB_Q_K_R_FIRST    0.6621979 0.97068210  0.1367932214 1.7696732 BEST
# SECOND:
# optim_SEA_kappa_K_R_SECOND           0.9919354  0.65934157 -0.056599110 1.5946779 BEST
# optim_SEA_kappa_Q_K_R_SECOND         0.9356289  0.69926770 -0.064671898 1.5702247 BEST
# THIRD.... in all sharks declines... BUG:
# kappa_ben specified as calibrated kappa here but not during calibration
# FORTH
# optim_SEA_kappa_SSB_K_R_FORTH.Rdata
# SIXTH
# optim_SEA_kappa_K_R_SIXTH      0.6912189 0.7391539 -0.06473318 1.3656396 # extinction with no fishing... BUG hopefully fixed
# optim_SEA_kappa_SSB_Q_K_SIXTH  0.5890372 0.7999809  0.07806167 1.4670798
# SEVENTH ... almost all error 54 "ERROR: ABNORMAL_TERMINATION_IN_LNSRCH"
# optim_SEA_kappa_Cali_Q  0.5794887 0.8533087  0.01046713 1.4432645
# optim_SEA_kappa_SSB_K_R 0.9283478 0.5356242 -0.02067474 1.4432973
load("optim_SEA_kappa_SSB_K_R.Rdata") # this refers to SEVENTH
# if calubrating kappa_ben too
kappa<-10^optim_SEA$par[length(optim_SEA$par)-1]
kappa_ben<-10^optim_SEA$par[length(optim_SEA$par)]
Q<-10^(optim_SEA$par[(nrow(df_param)+1):(length(optim_SEA$par)-2)])
r_max <- 10^(optim_SEA$par[1:nrow(df_param)])
df_param$r_max<-r_max
df_param$catchability<-Q
params_calibrated <- MizerParams(df_param, no_w = no_w, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics = fleetDynamics, selectivity_params = NA, catchability = NA, target = NA)
sim_calibrated <- project(params_calibrated, effort = constant_effort, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
plot(sim_calibrated)
# test unfished to see if tehre is coexistence and to calcualte Bref below
matrix_effort_nofishing<-matrix_effort_nofishing[301:900,]
params_unfished <- MizerParams(df_param, no_w = no_w, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics = fleetDynamics, selectivity_params = NA, catchability = NA, target = NA)
sim_calibrated_unfished <- project(params_unfished, effort= matrix_effort_nofishing, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
# plot(sim_calibrated_unfished)
```
# to do
*rescale catches before using them for calibration* - rescale by area - using either effort or speceis disribution - or use CPUE - or use SSB too. *ask for bioreg data* to cathy? or Donna? or Mike? -> I tried using CPUE and SSB but calibration is not working as well as with catches
are *diet dynamics* ok?
add *initial abundance* from ISMP? if so, rescale abundance given the same fishing mortatility - e.g. abundance of OR is high becasue fishing mortality for OR is high
figure out *plotPPMR* and what Jon used as preferred and realised PPMR
#-----------------------------------------
# plot recruitment *can skip*
#----------------------------------------------
```{r}
# get RDI - density independent
a1 <- getRDI(params,sim_calibrated@n[dim(constant_effort)[1],,],sim_calibrated@n_pp[dim(constant_effort)[1],], sim_calibrated@n_bb[dim(constant_effort)[1],], sim_calibrated@n_aa[dim(constant_effort)[1],], sim_calibrated@intTempScalar[,,(dim(constant_effort)[1]/dt)], sim_calibrated@metTempScalar[,,(dim(constant_effort)[1]/dt)])
# get RDD
a2 <- getRDD(params,sim_calibrated@n[dim(constant_effort)[1],,],sim_calibrated@n_pp[dim(constant_effort)[1],], sim_calibrated@n_bb[dim(constant_effort)[1],], sim_calibrated@n_aa[dim(constant_effort)[1],], sex_ratio = 0.5, sim_calibrated@intTempScalar[,,(dim(constant_effort)[1]/dt)], sim_calibrated@metTempScalar[,,(dim(constant_effort)[1]/dt)])
# #get RDD to rmax ratio
# rmaxratio <- a2/df_param$r_max
# plot(rmaxratio)
#
# rdiratio<-a1/a2
# plot(rdiratio)
# # explore available energy from food
# AE<-getAvailEnergy(params3, n, n_pp, n_bb, n_aa) # Calculates the amount of food \eqn{E_{a,i}(w)} exposed to each predator as a function of predator size. need to plot AE by species and size to understand food linkages and parameters
# also add the new getDiet, which calcualtes food proportion - Ask Asta as the function id in her code (or the gitHub mizer one)
```
# PROBLEM
*calculate or get RDI and RDD* and check the proportion. if RDI (non density dependente recruitment) is much higher than RDD it means that most of eggs (e.g. 0.999 99%) are lots and that the spp is stil there becasue only a very low number of eggs are needed to maintan population - i.e. even few individuals can recover the stock and the stock is hard to crush through fishing. I think it's the case for my spp and in particular spp 12 (OR) to 16
#-----------------------------------------
# validate catches and SSB modelled vs observed
#----------------------------------------------
```{r}
compareEql_outputs<-compareEql(areaEco, df_param, sim_calibrated, constant_effort, df_log_spp, calibration = FALSE)
plotYield_eql<-compareEql_outputs$plotYield_sp
ssbObs<-compareEql_outputs$ssbObs # needed for the function below on comparing trends
# now in calibration_server folder
# the folder has changed to Mizer-fleet_extension...
# setwd("/Users/nov017/Dropbox/Mizer-fleet/plot/calibration/SEVENTH")
# tiff("optim_SEA_kappa_SSB_K_R_SEVENTH_calibration.tiff", height=8, width=8, units ='in', res=300)
# print(p)
# dev.off()
```
#-----------------------------------------
# run time variant Fmort
#----------------------------------------------
```{r}
# Fmort adjusted
Fmort[is.na(Fmort)]<-0
Fmort_adjusted<-Fmort
# apply same transformation as in matrix_effort for the equilibrium and calibration phase.
Fmort_adjusted<- modFmort(Fmort_adjusted)
relative_effort<-rbind(constant_effort, Fmort_adjusted)
rownames(relative_effort)<-seq((1995-200), 2017)
# project the community
params_fitted <- MizerParams(df_param, no_w = no_w,interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=FALSE, selectivity_params = NA, catchability = NA, target = NA)
sim_fitted <- project(params_fitted, effort = relative_effort, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
# plot(sim_fitted)
```
# PROBLEMS
Abudnances increase if effort decreases in time from 1995, reference value - i.e. they recover. See brama and solandri as clear example. not sure this is a problem...
#-----------------------------------------
# validate time variant catch and SSB
#----------------------------------------------
```{r}
plotYield<-compareTrends(sim_fitted,sim_FD = NA, fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
plotSSB<-compareTrends(sim_fitted,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
# now in calibration_server folder
# setwd("/Users/nov017/Dropbox/Mizer-fleet/plot/calibration/SEVENTH")
# tiff("optim_SEA_kappa_SSB_K_R_SEVENTH_yieldTrendsScaled.tiff", height=6, width=10, units ='in', res=300)
# print(plotYield)
# dev.off()
# setwd("/Users/nov017/Dropbox/Mizer-fleet/plot/calibration/SEVENTH")
# tiff("optim_SEA_kappa_SSB_K_R_SEVENTH_SSBTrendsRaw.tiff", height=6, width=10, units ='in', res=300)
# print(plotSSB)
# dev.off()
```
# to do
check that:
1. mean_fmort is based on 1995-2005 data - OK
2. observed catcahes for calibration (in df_param) are based on 1995-2005 data (in FleetParam line 1400) - OK
3. Fmort (and Fmort_adjuset) based on 1995-2017 data - OK - even befoer if it's possible in the model
4. observed catches for validation (datValidationYieldSpp) based on 1995-2017 - OK - even before as for Fmort
# PROBLEM
- for some species, Fmort does not change in time (no available values). Can we caclualte these values given catch and effort?
- for these speceis, modelled yields are changing in time even if Fmort is constant e.g. 0.3 for squalus - trends in yields should match trends in biomass (but they don't)?...  yield = biomass X catchability X effort X selectivity.
-  for the reasons above all sharks have a bed fit
# to do
*validate modelled vs obs length frequency (or growth curve) using ISMP data*
# PROBLEM
- trends in SSB match trends in biomass (the scale in the 2 plots is different)... it makes sense
- bad fit
- no values for recent years. I also assumed Fmort as per last year but trends in catches changed for the worst as often Fmort actually decreased. - spp recover too fast when Fmort = 0 ?! though keep in ming that the 2 dataset (modelled and assessed) are rescaled from 0 to 1 independently so recoveries look higher in plots
- no values for not assessed spp
- if scaled across spp there is more agreement, but OR is way too high and blue granadier is way too low... also flathead adn morwong are too low. Calibration using SSB values does not give better results (error)
#-----------------------------------------
# save temporary data from steps above *option 1*
#----------------------------------------------
```{r}
# save(df_log_spp, df_selParam, df_price, df_cost_g, df_cost_opn, matrix_effort_nofishing,sim_calibrated_unfished, constant_effort,sim_calibrated, relative_effort, sim_fitted, df_param, theta, kappa, kappa_ben, kappa_alg, w_pp_cutoff, min_w_bb, w_bb_cutoff, datValidationYield, datValidationEffort, yieldObs_timeVariant, ssbObs, areaEco, file = "/Users/nov017/Dropbox/Mizer-fleet_extension/data/SEAmodel_opn1.RData")
```
#
#
#
#
#
#-----------------------------------------
# second run *option 2*
#----------------------------------------------
```{r}
# here you are tuning r_max and scaling areaEco up (by 1.5). this is becasue in option 1 raw modelled catches were much lower than observed, and abundances are much lower then in atlantis and SA and sometimes lower than the TAC
# new r_max parameters:
df_param2<-modQ(df_param)
# community at eql
params_calibrated2 <- MizerParams(df_param2, no_w = no_w, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics = fleetDynamics, selectivity_params = NA, catchability = NA, target = NA)
sim_calibrated2 <- project(params_calibrated2, effort = constant_effort, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 2)
# plot(sim_calibrated2)
# plotDietComp(sim_calibrated2)$p
# comapre fit now to fit from before
# compareEql(areaEco, df_param, sim_calibrated, constant_effort, df_log_spp, calibration = FALSE)$plotYield_sp
# compareEql(areaEco, df_param2, sim_calibrated2, constant_effort, df_log_spp, calibration = FALSE)$plotYield_sp
# time variant community
sim_fitted2 <- project(params_calibrated2, effort = relative_effort, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 2)
# plot(sim_fitted2)
# a<-plotBiomass(sim_fitted2, start_time = 1990, end_time =2017)$plot
# a+facet_wrap(~Species) # recoveries/increases given lower effort in more recent years
# NOTE when rescale = 0 values are given in tonnes for the whole system. Can change back in line 825.
plotYield<-compareTrends(sim_fitted,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
plotYield<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=3,areaEco)$plotYield_sp
plotSSB<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
# output data:
DataPlotYield<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$DataPlotYield
DataPlotSSB<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$DataPlotYield
# stop fishing
sim_calibrated_unfished2<- project(params_calibrated2, effort= matrix_effort_nofishing, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
# plot(sim_calibrated_unfished2)
# plotBiomass(sim_calibrated_unfished2)$plot + facet_wrap(~Species)
```
#-----------------------------------------
# re-calibrate
#----------------------------------------------
#-----------------------------------------
# save temporary data from steps above *option 2*
#----------------------------------------------
```{r}
df_param<-df_param2
sim_calibrated_unfished<-sim_calibrated_unfished2
sim_calibrated<-sim_calibrated2
sim_fitted<-sim_fitted2
# save(df_log_spp, df_selParam, df_price, df_cost_g, df_cost_opn, matrix_effort_nofishing,sim_calibrated_unfished, constant_effort,sim_calibrated, relative_effort, sim_fitted, df_param, theta, kappa, kappa_ben, kappa_alg, w_pp_cutoff, min_w_bb, w_bb_cutoff, datValidationYield, datValidationEffort, yieldObs_timeVariant, ssbObs, areaEco, file = "/Users/nov017/Dropbox/Mizer-fleet_extension/data/SEAmodel_opn2.RData")
```
#
#
#
#
#
#-----------------------------------------
# third run *option 3*
#----------------------------------------------
# equilibrium
```{r}
# here you are fixing squalus, accounting for onthogenetic shifts in diet, fixing diet, fixing growth curve, and adjusting cacthes given TAC and last changes. It all started becasue abundances were still low compared to Atlantis and SA, but there was an error in this calucaltion. However adjustments above were needed.
df_param3<-df_param2
theta3<-theta
constant_effort3<-constant_effort
### Squalus - fixed ####
# problem = abundance low, growth high, decreasing when unfished. fixed
theta3[1:16,7]<-0 # predation by genypterus was making squalus decreasing when unfished
constant_effort3[,7]<-constant_effort3[,7]*0.5 # reduce Fmort
constant_effort3[,7]<-constant_effort3[,7]*0.1 # reduce Fmort, after working with time varinat
theta3[7,1]<-0 # predation on mycto is unrealistic
df_param3[7,"alpha_g"]<-0.4 # lower growth efficiency to fix the growth curve
df_param3[,"alpha"]<-0.6 # def
df_param3[7,"alpha"]<-0.4 # lower assimilation efficiency to fix the growth curve
### growth curve - partially fixed ####
# fix growth curve for other sharks, hely and OR. Fix for some but community resrtucturing...
# df_param3[c(4,12,17,18,19),"alpha_g"]<-0.4
### onthogenetic shift - fixed ####
# w_pp_cutoff = 20
# min_w_bb = 1e-7
# w_bb_cutoff = 100
min_w_bb3 = 0.0001 # but small fish starve a little because allocation to PP is low
w_pp_cutoff3 = 5 # could be even lower, but mackerel would starve
w_bb_cutoff3 = 200 # sharks (including squalus) eat cardinal fish, flatheads and lots of macrobenthos (squids, octopods, crabs, praws, bivalves) - 32 kg can eat 300 g
### diet - not fixed ####
# problem = too much food for piscivorous
df_param3[,c(1,2,24,25)]
# mycto 100% on pp (1)
# squid and mackarel increase PP as they support all other fishes
df_param3[c(3,5),"avail_PP"]<-0.8 # shift towards lower catches...
# whiting and perch (2,4) and all other piscovourus
# df_param3[c(2,4,6,9,10,12,13,15,16), "avail_BB"]<-0.2 # community restructuring
# nemadactylus (8) eats small worms, crustaceans, molluscs and echinoderms 40% on PP and 60% on BB
df_param3[c(8),"avail_PP"]<-0.3  # some shfts towards lower catches e.g. platy
df_param3[c(8),"avail_BB"]<-0.5
#  seriorella/s eat pelagic invertebrates, salps, tunicates and small squids - SHOULD be CHANGED!
df_param3[c(11,14),"avail_PP"]<-0.3  # some shfts towards lower catches e.g. platy
df_param3[c(11,14),"avail_BB"]<-0.5
# benthic big sharks 0% of PP and 70% of BB
df_param3[c(7,17,18,19),"avail_PP"]<-0 # some shift towards lower catches e.g. mustelus but positive
df_param3[c(7,17,18,19),"avail_BB"]<-0.8
# starving OR, macrurus and genypterus ... not good for cacthes - macrurus in particular
# df_param3[c(12,13,16), "avail_BB"]<-0.5
# # how do I make fish eating fish??!!
# df_param3$w_inf/df_param3$beta
# df_param3$beta<-df_param3$beta/10
# theta3[]<-1
# df_param3$r_max[1:10]<-df_param3$r_max[1:7]*200
### cacthes - fixed ####
# adjust trends- yes
df_param3[2,"r_max"]<- df_param3[2,"r_max"]*1.5 # whiting
df_param3[9,"r_max"]<- df_param3[9,"r_max"]*1.5 # flathead
df_param3[10,"r_max"]<- df_param3[10,"r_max"]*1.5 # dories
df_param3[6,"r_max"]<- df_param3[6,"r_max"]*1.5 # redfish
df_param3[13,"r_max"]<- df_param3[13,"r_max"]*1.5 # macrurus
df_param3[15,"r_max"]<- df_param3[15,"r_max"]*1.5 # rexea
df_param3[7,"r_max"]<- df_param3[7,"r_max"]*2 # squalus
### catchability - if needed to fix catches ####
# catches has changed after increasing biomasses
# df_param3[1, "catchability"]<-1
# community at eql
params_calibrated3 <- MizerParams(df_param3, no_w = no_w, interaction = theta3, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff3, min_w_bb = min_w_bb3, w_bb_cutoff = w_bb_cutoff3, fleetDynamics = fleetDynamics, selectivity_params = NA, catchability = NA, target = NA)
sim_calibrated3 <- project(params_calibrated3, effort = constant_effort3, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 2)
# plot(sim_calibrated3)
# plotFeedingLevel(sim_calibrated3) + facet_wrap(~Species)
# plotDietComp(sim_calibrated3)$p
# compare fit before with fit now
# compareEql(areaEco, df_param2, sim_calibrated2, constant_effort, df_log_spp, calibration = FALSE)$plotYield_sp
# compareEql(areaEco, df_param3, sim_calibrated3, constant_effort3, df_log_spp, calibration = FALSE)$plotYield_sp
```
#-----------------------------------------
# re-calibrate *option available - need to try*
#----------------------------------------------
# optimisation criteria *skip if no calibration*
```{r}
Initialcomm = sim_calibrated3
kappa = kappa
kappa_ben = kappa_ben
df_param = df_param3
# kappa, r_max and Q
logR <- log10(Initialcomm@params@species_params$r_max)
logQ <- log10(df_param$catchability)
logK <- log10(kappa)
logK_ben <- log10(kappa_ben)
logParams <- c(logR, logQ, logK, logK_ben)
# lower and upper are needed for calibration with Q as this value should not be above 1
lower = c(log10(Initialcomm@params@species_params$r_max*0.01),log10(rep(0.001, nrow(df_param))), log10(kappa*0.01), log10(kappa_ben*0.01))
upper = c(log10(Initialcomm@params@species_params$r_max/0.01),log10(rep(1, nrow(df_param))), log10(kappa/0.01), log10(kappa_ben/0.01))
# for mizerParams()
theta = theta3
fleetDynamics = FALSE
selectivity_params = NA
catchability = NA
target = NA
dt =  0.25
# for project()
kappa_ben = kappa_ben
kappa_alg = 0
w_pp_cutoff = w_pp_cutoff3
min_w_bb = min_w_bb3
w_bb_cutoff = w_bb_cutoff3
management = FALSE
multiFleet = FALSE
constant_effort = constant_effort3
effort = constant_effort
# rownames(effort)<-seq(1:200)
price = NA
cost = NA
# for error functions
meantsteps = 30
extinction_test = TRUE
extinct_threshold = 0.9
diet_steps = 0
```
# run calibration locally *skip if no calibration*
```{r}
# upload calibration function
source("/Users/nov017/Dropbox/Mizer-fleet/R/Calibration_function.R")
# optim function
optimizer_count=0 # Initialize count of function evaluations
# debug(calibrate)
# undebug(calibrate)
optim_SEA   <- optim(par = logParams,
lower=lower,
upper=upper,
method ="L-BFGS-B",
fn = calibrate,
SSBcali = TRUE,
rankCali = FALSE,
Q = FALSE,
K = TRUE,
R = TRUE)
# save calibrated param
setwd("/Users/nov017/Dropbox/Mizer-fleet_extension/calibration_local")
save(optim_SEA, file = "optim_SEA_kappa_SSB_K_R_opn3.Rdata")
```
9882*33
optim_SEA
kappa<-10^optim_SEA$par[length(optim_SEA$par)-1]
kappa_ben<-10^optim_SEA$par[length(optim_SEA$par)]
Q<-10^(optim_SEA$par[(nrow(df_param)+1):(length(optim_SEA$par)-2)])
r_max <- 10^(optim_SEA$par[1:nrow(df_param)])
df_param$r_max<-r_max
df_param$catchability<-Q
params_calibrated3 <- MizerParams(df_param, no_w = no_w, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics = fleetDynamics, selectivity_params = NA, catchability = NA, target = NA)
sim_calibrated3 <- project(params_calibrated3, effort = constant_effort, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 0)
plot(sim_calibrated3)
compareEql_outputs # calcualted before df_param etc. was overwtirren by df_param3 etc.
compareEql_outputs_opn3<-compareEql(areaEco, df_param, sim_calibrated3, constant_effort, df_log_spp, calibration = FALSE)
compareEql_outputs_opn3
spp = as.character(df_param3[19,1])
relative_effort3<-relative_effort
relative_effort3[,7]<-relative_effort3[,7]*0.5
relative_effort3[,7]<-relative_effort3[,7]*0.1 # bycatch... this is perfect
sim_fitted3 <- project(params_calibrated3, effort = relative_effort3, dt = dt, fleetDynamics = FALSE, multiFleet = FALSE, management = FALSE, price = NA, cost = NA, diet_steps = 2)
plot(sim_fitted3)
plotYield<-compareTrends(sim_fitted,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=3,areaEco)$plotYield_sp
plotYield2<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=3,areaEco)$plotYield_sp
plotYield3<-compareTrends(sim_fitted3,sim_FD = NA,fleetDynamics = FALSE,type = "yield",yieldObs_timeVariant,ssbObs,rescale=3,areaEco)$plotYield_sp
plotSSB<-compareTrends(sim_fitted,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
plotSSB2<-compareTrends(sim_fitted2,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
plotSSB3<-compareTrends(sim_fitted3,sim_FD = NA,fleetDynamics = FALSE,type = "SSB",yieldObs_timeVariant,ssbObs,rescale=0,areaEco)$plotYield_sp
plotYield
plotYield2
plotYield3
plotSSB
plotSSB2
plotSSB3
kappa
kappa_ben
r_max
plotYield3
e<-getBiomass(sim_fitted3)
dim(e)
e<-e[223,] # in 1995 (200) or in 2017 (223)
(e*areaEco)/1000000
e<-getBiomass(sim_fitted2)
dim(e)
e<-e[223,] # in 1995 (200) or in 2017 (223)
(e*areaEco)/1000000
diet<-sim_fitted3@diet_comp # pred X pred size X prey X prey size
f<-rowSums(aperm(diet,c(1,2,3,4)),dims=3) # sum over prey size
f<-rowSums(aperm(f,c(1,3,2)),dims=2) # sum over predator size
val<-1e10
options("scipen"=100)
sort(f[16,]*val) # prey
sort(f[,9]*val) # predators
diet<-plotDietComp(sim_fitted3)$dietData
unique(diet$predator)
unique(10^(diet$predsize))
spp = as.character(df_param3[9,1]) # choose a spp
size = unique(10^(diet$predsize))[80:99] # chose a size range
diet_predator<-diet %>%
filter(predator == spp, value !=0, 10^(predsize) > 1000) %>%
group_by(prey) %>%
dplyr::summarise(value = sum(value)) %>%
mutate(contribution = (value/sum(value))*100)
diet_comp <- diet %>%
group_by(prey) %>%
dplyr::summarise(value = sum(value)) %>%
mutate(contribution = (value/sum(value))*100)
view(diet_predator)
spp
