theme(text = element_text(size=18),
axis.text.x = element_text(angle=90, hjust=0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# adjust df_target to include catchability in df_param ...
# df_target<-as.data.frame(df_target) %>%
#   mutate(fleet = rownames(df_target)) %>%
#   gather(species, q, -fleet) %>%
#   left_join(df_param[,c("species", "catchability")]) %>%
#   mutate(q = q*catchability) %>%
#   select(-catchability) %>%
#   spread(species, q)
# rownames(df_target)<-df_target$fleet
# df_target<-df_target %>% select(-fleet)
# df_target<-as.matrix(df_target)
```
# TO DO
need to change the description of the target matrix in the paper? No difference
- old option: when considering the proportion of catch by fleet: the total catch of each fleet sums to 1, but the total catch of each spp could be higher than 1; i.e. yield > biomass (yield = biomass X target X effort).
- when considering the proportion of catch by speceis: the total catch of each speceis sums to 1, but the total catch for each fleet can be higher than 1 (e.g. trawlin cacthes 0.9 of many spp).
- BIG EYE is caught here but not in the model above with Fmort - to check and add Fmort based on catches for this spp.
#-----------------------------------------
# adjust df_selParam_new, df_price_new, df_cost2
#----------------------------------------------
```{r}
# keep only spp and fleets specified above
df_selParam_new<-df_selParam %>%
filter(species %in% df_param$species,
subfleet %in% df_main_metier) %>%
mutate(subfleet = case_when(subfleet == "GHAT - Southern Shark Gillnet" ~ "SSG",
subfleet == "South East Trawl Fishery - Danish Seine" ~ "SED",
subfleet == "South East Trawl Fishery - Otter trawl deepSlope" ~ "SET-DS",
subfleet == "South East Trawl Fishery - Otter trawl shelf" ~ "SET-SH",
subfleet == "South East Trawl Fishery - Otter trawl upperSlope" ~ "SET-US"))
df_price_new<-df_price %>%
filter(species %in% df_param$species)
# add values for 2017
addPrice2017<-df_price_new %>%
filter(year == "2016") %>%
mutate(year = "2017")
df_price_new<-rbind(df_price_new, addPrice2017)
# matrix of prices
df_price_new = spread(df_price_new, species, price)
rownames(df_price_new)<-df_price_new$year
df_price_new<-df_price_new[,-1]
df_price_new<-as.matrix(df_price_new)
df_price_new<-df_price_new[, df_param$species] # order spp
# cost - can have differnt units
# df_cost = df_cost_g $ opn-1 g-1
# df_cost2 = df_cost_opn $ opn-1
# divide fixed and variable costs - variable costs vary with the amount of fishing effort or catch, and fixed costs do not vary with effort (Pascoe 2014)
# After chat with Beth and Ingrid - use cost/g - still need to figure out units in eqn...
df_cost2<-df_cost_opn %>%
filter(subfleet %in% df_main_metier) %>%
mutate(cost_type = ifelse(param_type %in% c("Crew","Fuel","Packaging","Freight"), "fixed", "variable")) %>%
group_by(subfleet, year, cost_type) %>%
dplyr::summarise(cost = sum(param_value, na.rm=TRUE)) %>%
mutate(subfleet = case_when(subfleet == "GHAT - Southern Shark Gillnet" ~ "SSG",
subfleet == "South East Trawl Fishery - Danish Seine" ~ "SED",
subfleet == "South East Trawl Fishery - Otter trawl deepSlope" ~ "SET-DS",
subfleet == "South East Trawl Fishery - Otter trawl shelf" ~ "SET-SH",
subfleet == "South East Trawl Fishery - Otter trawl upperSlope" ~ "SET-US"))
# cost need to have the same years as price - temporary values here
addCost2015<-df_cost2 %>%
filter(year == "2014") %>%
mutate(year = "2015")
addCost2016<-addCost2015 %>%
mutate(year = "2016")
addCost2017<-addCost2015 %>%
mutate(year = "2017")
df_cost2<-rbind(df_cost2,addCost2015,addCost2016, addCost2017)
# matrix of costs
df_cost2<-acast(df_cost2, formula = year ~ subfleet ~ cost_type, value.var = "cost")
df_cost2<-df_cost2[,rownames(df_target),] # order cost by fleet
# Problem from previous version (IMBeR version):
# 1. not possible to reproduce observed trends in catches and effort etc. after calibrating ke and scaling price parameters with the FD running - and this is because the calibration forced the model to reach equilibrium, which due to model structure and managemtn constrains is when MEY is reached and effort is stabilised. loosing dynamics. So instead, run the time variant version of the FD model without FD calibraion and tune parameters for a better fit.
# 2. no costs difference between fleets results in fitting problems. Use costs in g (cost of fishing 1 g of fish and different between fleets as bsed on catches) instead of coasts per operation (same for all trawling as based on data at teh fishery level?). Also, could use costs in g calculated for trawlers of the shelf and rescale that using scaling factors from beth (Atlantis)
# 3. check for bugs in managemtn as at present fishing steeply declines if only one specis is declining despite the
# OPTION 1 use costs in g or use costs in g rescaled as per Beth's data - NO CHANGE from above
# Beth's adjustment on costs - see email 'price' and file 'costs_from_SESSF_2005'
ref<- df_cost2[,3,1] # trawlers on the shelf
df_cost2[,1,1]<-ref*1.5 # Danish seiners - see agenda, could be *0.6 or *1.5?
df_cost2[,2,1]<-ref*0.67 # deep slope
df_cost2[,4,1]<-ref*0.67 # upper slope - these is the fishery using the biggers adn more expensive boats, so if you are using the costs per operation unit, this should be highest
df_cost2[,5,1]<-ref*0.94 # gillnet
ref<- df_cost2[,3,2] # trawlers on the shelf
df_cost2[,1,2]<-ref*1.5 # Danish seiners
df_cost2[,2,2]<-ref*0.67 # deep slope
df_cost2[,4,2]<-ref*0.67 # upper slope
df_cost2[,5,2]<-ref*0.94 # gillnet
```
# TO DO
there are data on profits that can be used for calibration/validation - see xlsx file and ASK INGRID on how to use these data
#-----------------------------------------
# Set fixed parameters
#----------------------------------------------
```{r}
kappa = kappa # intercpet of PP
kappa_ben = kappa_ben # intercpet of BB benthic spectrum
kappa_alg = kappa_alg # intercpet for algae spectrum
lambda = 2.33 # slope of spectrum - def
lambda_ben = 2.33 # slope of spectrum - def
w_pp_cutoff = w_pp_cutoff
min_w_bb = min_w_bb
w_bb_cutoff = w_bb_cutoff
n = 2/3 # Exponent for max. food intake - def
q = 0.8 # Exponent for volumetric search rate - def
dt = 0.25
no_w = 100 # def
```
#-----------------------------------------
# Calculate biomass reference levels
#----------------------------------------------
```{R}
# Calculate biomass reference levels (Bref, Bmsy, Bhist)
Blevel<-getBlevel(sim_calibrated_unfished,matrix_effort_nofishing,constant_effort,sim_calibrated,df_param,sim_fitted)
bioUnfished = Blevel$bioUnfished
msy = Blevel$msy
p = Blevel$p
Bhist = Blevel$Bhist
# add bioUnfished, Bmsy and Bhist, B0 as per SA to df_param
df_param<-df_param %>%
left_join(select(msy, c(species, Bmsy))) %>%
left_join(select(Bhist, c(species, Bhist))) %>%
left_join(bioUnfished %>% dplyr::rename(Bref = bioUnfished)) %>%
mutate(B0_SA = (getBiomass(sim_calibrated)[200,])*100/df_param$changesSSB)
# plot values
bio<-df_param %>%
select(species, Bref,Bmsy,Bhist,B0_SA) %>%
mutate(bioMod = getBiomass(sim_calibrated)[200,])
bio_plot<-bio %>% gather(variable, value, -species)
p<-ggplot(bio_plot, aes(x = variable, y = value))+
geom_point()+
facet_wrap(~species, scale ="free_y")+
theme(axis.text.x = element_text(size=10, angle = 90, hjust=0.5))
# check reference levels. using Bmsy and Bhist, fishing is more likely to happen
# bio$fishing<-ifelse(bio$bioMod<bio$Bmsy*0.5, "no fishing", "")
```
# TO DO
1. need to transfor all of this from input (effort) to output (catch) control
2. how do we calculate Bmey instead of 1.2*Bmsy (https://www.youtube.com/watch?v=7DNhqtYf47E)? By running the model increasing costs instead of effort?
3. add compliance term in effort equation?
#-----------------------------------------
# Calculate scaling costs and price
#----------------------------------------------
```{r}
# scaling cost area scales both cost and effort becasue it transform them from operation to m3. then you should have separate scaling for simulations etc.
# costs - should you use the scaling costs to transform $ g-1 opn-1 into $ g-1 m-3 (or $ opn-1 into $ m-3 )?
scaling_cost_area = 14000*10*20 # mean trawl length from SESSFdataCleaning considering trawling and gill net = 14 km = 14000 m. net opening: 20m *10m
scaling_cost_area = scaling_cost_area*5000 # I need justifications for this 140 000 000 000 m3 fished in a tralwing operation (Beth's suggestion below)?! this makes things ... running cost wise?
df_cost3<-df_cost2
df_cost3[]<-df_cost3/scaling_cost_area
# Beth -> if you need a further rescaling -> use soak time for a net
# scaling for costs alone
# e.g. increase costs shoud decrease profits and effort - nothing changes unless costs are disproportionally increased. This is due to the units in this model....
scaling_costs<-1
scaling_costs<-c(0.000001,1,1,1,1)
df_cost3[,1,] = df_cost3[,1,]*scaling_costs[1] # making SED very cheap to run -> positive profits -> increase in effort if no spp < 40%
df_cost3[,2,] = df_cost3[,2,]*scaling_costs[2]
df_cost3[,3,] = df_cost3[,3,]*scaling_costs[3]
df_cost3[,4,] = df_cost3[,4,]*scaling_costs[4]
df_cost3[,5,] = df_cost3[,5,]*scaling_costs[5]
# scaling for price alone
# e.g. decrease price should decrease profits and effort  -
scaling_price<-1
df_price_new[]<-df_price_new*scaling_price
```
#-----------------------------------------
# Calcualte fleet param (ke_fleet, initial effort, scaling effort)
#----------------------------------------------
```{r}
# ke TO UPDATE THE BELOW
# ke is effective only if effort is driven by profits and not overwritten by the managemtn rule.
# if you are considering ke also when effort is forced to decrease (by management - see line 694) values higher than 1 will mild the decreases (or increase!) in effort while values lower than 1 will further decrease effort. Not sure it should be the same parameter used in both cases ....
# see units for these and work out value, but now set as 1...
# ke_fleet = data.frame(fleet= rownames(df_target), ke = rep(0.01, 5))
# ke_fleet = data.frame(fleet= rownames(df_target), ke = rep(scaling_cost_area, 5))
ke_fleet = data.frame(fleet= rownames(df_target), ke = rep(1, 5)) # use this to figure out the scaling of ke by comapring output effort and output profits
ke_fleet = data.frame(fleet= rownames(df_target), ke = c(500000,70000,250000,500000,10)) # 100000 # decreasing ke decreases the rate of change
# tuning price and costs
scaling_price = 1
# initial effort see campareTrends for more info on how effort is treated and plotted.
# if this is the unit maybe initial effort shuld not be higher than 1 - e.g. the whole m3 fished? or maybe it can be as in the whole m3 can be fished more than once in a year? but unrealistic...
trial<-datValidationEffort %>%
ungroup() %>%
mutate(opn = (opn*scaling_cost_area)/areaEco) %>% # from opn to m3 trawled in m3
filter(YEAR == 2006)
trial<-trial[c(3,4,5,6,1),] # reorder fleets
initial_effort = trial$opn
# initial effort is from data and no matter the scaling you are using, the first value of modelled and observed will be the same!
# scaling for effort alone
# if I increase effort, effort it's OK because it's rescaled, but Fmort is super low and yeilds are too low too
scaling_effort<-rep(1,5) # needed in DataFunction anyway
# initial_effort = initial_effort*scaling_effort
# initial_effort*df_target needs to be on the scale of relative_effort
colSums(df_target*initial_effort) # this uses catch and effort data
relative_effort[212,] # this uses Fmort
### note: this initial effort could be the value for the multifleet component....
```
#-----------------------------------------
# Tune Q
#----------------------------------------------
```{r}
# df_target is not real Q as the one incorporated in Fmort, it sums to 1 and is a proportion of how much each fleet cacthes the whole papolation available.
df_target_bmsy <- df_target
# df_target_bmsy[, "squalus spp."]<- df_target_bmsy[, "squalus spp."]*0.5 # this needs to be reduced in all fisheries as it's bycatch
# for squid and tracurus, df_target assumes these spp are fished by the fleets indicated here. but they are not and their catchability is usiually quite low - here represented as food
df_target_bmsy[, "nototodarus gouldi"]<- df_target_bmsy[, "nototodarus gouldi"]/25
df_target_bmsy[, "trachurus declivis"]<- df_target_bmsy[, "trachurus declivis"]/40
# OPTION 1 fix upper slope
df_target_bmsy[4, "seriolella punctata"]<- df_target_bmsy[4, "seriolella punctata"]/2
# OPTION 2 fix shelf - move target from shelf to sed
df_target_bmsy[3, "centroberyx affinis"]<- df_target_bmsy[3, "centroberyx affinis"]/2
df_target_bmsy[3, "nemadactylus macropterus"]<- df_target_bmsy[3, "nemadactylus macropterus"]/2
df_target_bmsy[3, "seriolella brama"]<- df_target_bmsy[3, "seriolella brama"]/2
# OPTION 4 fix sed increase catch by moving some spp from shelf to sed
df_target_bmsy[1, "centroberyx affinis"]<- df_target_bmsy[1, "centroberyx affinis"]*500
df_target_bmsy[1, "nemadactylus macropterus"]<- df_target_bmsy[1, "nemadactylus macropterus"]*10
df_target_bmsy[1, "seriolella brama"]<- df_target_bmsy[1, "seriolella brama"]*50
# OPTION 5 increase sed effort by removing some declning spp - need to reduce these as much as possible
df_target_bmsy[1, "helicolenus barathri"]<- 0
df_target_bmsy[1, "seriolella punctata"]<- 0
df_target_bmsy[1, "galeorhinus galeus"]<- 0
df_target_bmsy[1, "squalus spp."]<- 0
df_target_bmsy[1, "centroberyx affinis"]<- 0
# OPTION 6 decrease catches in US
# df_target_bmsy[4, "macruronus novaezelandiae"]<- df_target_bmsy[4, "macruronus novaezelandiae"]/1.5
df_target_bmsy[4, "helicolenus barathri"]<- df_target_bmsy[4, "helicolenus barathri"]/2 # could increase this to 8 as this spp is not an important one? but need to think mode of this
df_target_bmsy[4, "galeorhinus galeus"]<- 0
df_target_bmsy[4, "centroberyx affinis"]<- df_target_bmsy[4, "centroberyx affinis"]/2
# OPTION 7 - decrease shelf catch
df_target_bmsy[3,]<-df_target_bmsy[3,]*0.8
# OPTION 8 - decrease blue w
# df_target_bmsy[1, "seriolella brama"]<- df_target_bmsy[1, "seriolella brama"]*0.1
# df_target_bmsy[3, "seriolella brama"]<- df_target_bmsy[3, "seriolella brama"]*0.1
# df_target_bmsy[4, "seriolella brama"]<- df_target_bmsy[4, "seriolella brama"]*4
# df_target_bmsy[5, "seriolella brama"]<- df_target_bmsy[5, "seriolella brama"]*0.1
# BETH:
# need to fix blue wharehow (seriorelle b.) -> reduce bycatch from other fisheries
# need to fix flathead -> catch are increasing
# check increasing abundances - if not realistic you need to change growth parameters and/or recruitment param - see sharks as they all recover to 1995 (modelled) values - though 1995 is a 'depleted' year/abundance
# 2 problems with flathead: 1) Fmort in 2006 is much lower than for the Fmort model:
colSums(df_target_bmsy*initial_effort)
relative_effort[212,]
colSums(df_target*initial_effort)
relative_effort[212,]
# I can
# a) increase Q for SED by 8 time. That results in about the same Fmort and fixes the flathead trend. BUT total Q for flathead is Q is 3.7!; trends in whiting is not great as well as trends at teh fleet level in particular for SED
# df_target_bmsy[1,"platycephalus richardsoni"]<-df_target_bmsy[1,"platycephalus richardsoni"]*8
# b) increase effort for e.g. SED (or SET) and decrease Q for all spp but flathed. BUT the effort plots won't look as good and initial effort is not based on data any longer
# 2 predation release from squid, which declines (larvae predation as squid eats fish individuals that are ~12 g not sharks as they enter the community at a much higher weight)
theta2<-theta
# theta2["nototodarus gouldi",]
# theta2["nototodarus gouldi","platycephalus richardsoni"]<-3
# I can
# a) increase predation from other small fish. but this is very slightly effective
# theta2["sillago flindersi","platycephalus richardsoni"]<-1
# to conclude: the problem is a combination of fishing mortality being low and predation being low so that the population increases. An important problem with both model is that flathead abundance is well underestimated (~ 5000t in model and 20000 t in SA - I remember the problem with flathead in the Fmort model being tat increases in this spp lead to decreases/collapses/increases of squalus).
```
#-----------------------------------------
# First model run
#----------------------------------------------
```{r}
# start with community in 2006 (sim_fitted) or community at equilibium (sim_calibrated)
initial_n = sim_fitted@n[212,,]
initial_n_pp = sim_fitted@n_pp[212,]
initial_n_bb = sim_fitted@n_bb[212,]
params_FD <- MizerParams(df_param, interaction = theta2, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics = TRUE, selectivity_params = df_selParam_new, catchability = df_target_bmsy, target = df_target_bmsy)
# params_FD@psi
# params_FD@intake_max
# params_FD@search_vol
# params_FD@metab
# params_FD@mu_b
# params_FD@selectivity
# params_FD@catchability
# params_FD@interaction
sim_FD_bmsy <- project(params_FD, effort = 0, dt = dt, fleetDynamics = TRUE, multiFleet = FALSE, management = TRUE, price = df_price_new, cost = df_cost3, diet_steps = 2, ke = ke_fleet, initial_n = initial_n, initial_n_pp = initial_n_pp, initial_n_bb = initial_n_bb, initial_effort = initial_effort, scaling_price = scaling_price, Blevel_management = "Bmsy")
# # compare profit and effort to figure out ke
# sim_FD_bmsy@effortOut
# sim_FD_bmsy@profit
# sim_FD_bmsy@BioOut[[22]]
# compared with other communities
plot(sim_calibrated)
plot(sim_fitted)
plot_CN(sim_FD_bmsy)
plotFleet(sim_FD_bmsy)
# diet
dim(sim_FD_bmsy@diet_comp) # predator X size X prey X prey size
plotDietComp(sim_FD_bmsy)$p
image(sim_FD_bmsy@diet_comp[19,,9,])
# growth
df_param[,c(1,5,8)]
df_param$max_age<-c(4,7,10,40,25,44,30,40,12,18,22,100,25,23,16,30,15,16,55)
spp = as.character(df_param[19,1])
max_age = df_param[19,"max_age"]
plotGrowthCurves(sim_FD_bmsy, species = spp, max_age = max_age)
```
#-----------------
#-----------------------------------------
# scenarios fleet structure
#----------------------------------------------
```{r}
rm(list=ls())
library(tidyverse)
library(devtools)
library(plyr)
library(Rcpp) # this will allow you to run the inner_project_loop
library(reshape2)
library(inline)
library(ggplot2)
library(vegan)
# install.packages("shiny")
library(mizer) # if inner_loop error, you need to upload mizer
library(shiny)
setwd("/Users/nov017/Dropbox/Mizer-fleet/R")
source("data.R")
source("help.R")
source("MizerParams-class.R")
source("MizerSim-class.R")
source("plots.R")
source("project_methods.R")
source("project.R")
source("RcppExports.R")
source("selectivity_funcs.R")
source("summary_methods.R")
source("wrapper_functions.R")
source("DataFunction.R")
# load data
# load("/Users/nov017/Dropbox/Mizer-fleet/R/model/FDData_Nov.RData") # FDData_opn3.RData or FDData_opn2.RData (was FDData_Nov.RData)
# new folder
load("/Users/nov017/Dropbox/Mizer-fleet_extension/data/FDData_opn3.RData")
# not sure I should specify this here?
sim = sim_FD_bmsy
df_param = df_param
interaction = theta
kappa = kappa
kappa_ben = kappa_ben
kappa_alg = kappa_alg
w_pp_cutoff = w_pp_cutoff
min_w_bb = min_w_bb
w_bb_cutoff = w_bb_cutoff
fleetDynamics = TRUE
selectivity_params = df_selParam_new
catchability = df_target_bmsy
target = df_target_bmsy
effort = 0
dt = 0.25
management = TRUE
price = df_price_new
cost = df_cost3
diet_steps = 0
ke = ke_fleet
scaling_price = scaling_price
Blevel_management = "Bmsy"
initial_n = initial_n
initial_n_pp = initial_n_pp
initial_n_bb = initial_n_bb
initial_effort = initial_effort
######## Scenario: initial caommunity as per last time step of time-variant community. Run forward using price and costs as per last time step of time-variant community, but changing interaction matrix as per scenarios.
####### initial community
initial_n_scenario = sim@n[nrow(sim@n),,]
initial_n_pp_scenario  = sim@n_pp[nrow(sim@n_pp),]
initial_n_bb_scenario  = sim@n_bb[nrow(sim@n_bb),]
initial_effort_scenario = sim@effortOut[dim(sim@effortOut)[1],]
####### forward price and costs
t_max = 10 # if you run it for too long it's going to collaps...
price_forward = t(replicate(t_max, price[nrow(price),]))
rownames(price_forward)<-seq(1:t_max)
cost_forward1 <- t(replicate(t_max, cost[nrow(cost),,1]))
rownames(cost_forward1)<-seq(1:t_max)
cost_forward2 <- t(replicate(t_max, cost[nrow(cost),,2]))
rownames(cost_forward2)<-seq(1:t_max)
cost_forward <-array(c(cost_forward1,cost_forward2), dim = c(t_max,dim(cost)[2],dim(cost)[3]))
####### interaction matrix options
######## note - be carefull with these values, does this mean that exploitation rate is higher than 1? the values below act as catchability only, but if you add all the Fmort from all the fleets? check that exploitation rate (catch/biomass at t) is lower than 1
# a<-getBiomass(sim)
# b<-sim_FD_calibrated@yield
# b<-rowSums(aperm(b,c(1,2,4,3)),dims=3) # sum over size
# b<-rowSums(b,dims=2)
# c<-b/a
# c[c>0.2] # exploitation rate for all spp is less than 20%
######## trial model to understand things - status quo (initial community and fleets as per sim_FD_bmsy)
# ####### everything is collapsing - so set condisions as per sim_FD_bmsy!!!!!! really need to understand why adn fix it becasue scenarios are not supposed to be like this.....
# ####### initial community instead
# # start with community in 2006 (sim_fitted) or community at equilibium (sim_calibrated)
# initial_n = sim_fitted@n[212,,]
# initial_n_pp = sim_fitted@n_pp[212,]
# initial_n_bb = sim_fitted@n_bb[212,]
# initial_effort_scenario = initial_effort
# # # price and costs as per ... this should not change things much
# # price_forward = df_price_new
# # cost_forward = df_cost3
# #######
params_trial <- MizerParams(df_param, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=TRUE, selectivity_params = selectivity_params, catchability = catchability, target = target)
sim_trial <- project(params_trial, effort = 0, dt = dt, fleetDynamics = TRUE, management = TRUE, multiFleet = FALSE, price = price_forward, cost = cost_forward, diet_steps = 0, ke = ke, initial_effort = initial_effort_scenario, scaling_price = scaling_price, Blevel_management = Blevel_management, initial_n = initial_n_scenario, initial_n_pp = initial_n_pp_scenario , initial_n_bb = initial_n_bb_scenario )
# sim_trial@effortOut[dim(sim_trial@effortOut)[1],]
# sim_trial@BioOut[[dim(sim_trial@effortOut)[1]]]
# plotBiomass(sim_trial)
# plot_CN(sim_trial)
# theta2
plotFleet(sim_trial)
plot_CN(sim_trial)
####### should recovery speceis not being caought in any of these scenario?! using recent data does not change the target matrix as it details how much of the whatever catch is split into teh main fleet, but may change the list of main fleet - i.f. deep slope may be togethr with eth upper slope
######## target unfished
df_target_unfished<-df_target_bmsy
df_target_unfished[]<-0
params_unfished <- MizerParams(df_param, interaction = theta, kappa = kappa, kappa_ben = kappa_ben, kappa_alg = kappa_alg, w_pp_cutoff = w_pp_cutoff, min_w_bb = min_w_bb, w_bb_cutoff = w_bb_cutoff, fleetDynamics=TRUE, selectivity_params = selectivity_params, catchability = df_target_unfished, target = df_target_unfished)
# params_unfished@selectivity
sim_unfished <- project(params_unfished, effort = 0, dt = dt, fleetDynamics = TRUE, management = TRUE, multiFleet = FALSE, price = price_forward, cost = cost_forward, diet_steps = 0, ke = ke, initial_effort = initial_effort_scenario, scaling_price = scaling_price, Blevel_management = Blevel_management, initial_n = initial_n_scenario, initial_n_pp = initial_n_pp_scenario , initial_n_bb = initial_n_bb_scenario )
plotFleet(sim_unfished) # effort and profits are calcualted anyway - it's OK fixed below
######## no competition - WORKING
# each spp is targeted by the fleet that catches it the most - no overlapping
library(matrixStats)
df_target_NoCompetition<-df_target_bmsy
trial<-colMaxs(df_target_NoCompetition)
trial<-trial[-which(trial == 0)]
df_target_NoCompetition[df_target_NoCompetition %in% trial]<-1
df_target_NoCompetition[df_target_NoCompetition<1]<-0
######## full competition - NOT WORKING but OK
# all fleet target all species - full overlapping
df_target_FullCompetition<-df_target_bmsy
df_target_FullCompetition[]<-1
df_target_FullCompetition[, "myctophids"]<-0
df_target_FullCompetition[, "trachurus declivis"]<-0
df_target_FullCompetition[, "nototodarus gouldi"]<-0
df_target_FullCompetition[, "helicolenus barathri"]<-0
# df_target_FullCompetition[df_target_FullCompetition!=0]<-1 # this would be the best, but results are difficult to interpret....
######## no bycatch (and spp under rebilding strategies) - WORKING
# NOTE 2 fisheries are based on spp under recovery strategies - OR and school shark
df_target_NoBycatch<-df_target_bmsy
df_target_NoBycatch[df_target_NoBycatch < 0.1]<-0 # bycatch
df_target_NoBycatch[, "seriolella brama"] <- 0 # rebuilding
df_target_NoBycatch[, "rexea solandri"] <- 0 # rebuilding
# df_target_NoBycatch[, "hoplostethus atlanticus"] <- 0 # rebuilding or not really?
df_target_NoBycatch[, "galeorhinus galeus"] <- 0 # rebuilding
# further reduce pressure on key bycatch spp: squalus
df_target_NoBycatch[, "squalus spp."]<-df_target_NoBycatch[, "squalus spp."]*0.5
# df_target_NoBycatch[, "pristiophorus cirratus"]<-df_target_NoBycatch[, "pristiophorus cirratus"]*0.5
######## target more target - see options
# define (main target and?) most valuable spp and increase fishing on these by the fleets that already catch them - by 50% - working, set to 1 - not working
# yes I have checked prices according to data and they match with sharks being the higehst value spp.
valuable<-sort(-df_price_new[nrow(df_price_new),])
valuable<-names(valuable)[1:6]
# option 1 - NOT WORKING (squalus and morwong limiting effort - though they decrease because we fish more of a species they are linked too and not because of overexploitation!). when we fish galeo to 1: fishing galeo increases squalus, but then fishing is lowered, galeo increases and squalus decreases - competiotion over food?
df_target_MoreTarget<-as.data.frame(df_target_bmsy) %>%
mutate(fleet = rownames(df_target_bmsy)) %>%
gather(key = "species", value = "interaction", - fleet) %>%
mutate(interaction = ifelse(species %in% valuable & interaction > 0, 1, interaction))
df_target_MoreTarget<-acast(df_target_MoreTarget, fleet ~ species)
# OR, galeo (yes), genipt, mustelus, platy, zeus
# df_target_MoreTarget2<-df_target_bmsy
# df_target_MoreTarget2[,"platycephalus richardsoni"]<-1
# option 2 - WORKING
df_target_MoreTarget<-as.data.frame(df_target_bmsy) %>%
mutate(fleet = rownames(df_target_bmsy)) %>%
gather(key = "species", value = "interaction", - fleet) %>%
mutate(interaction = ifelse(species %in% valuable & interaction > 0, interaction*5, interaction)) %>%
mutate(interaction = ifelse(interaction > 1, 1, interaction))
df_target_MoreTarget<-acast(df_target_MoreTarget, fleet ~ species)
######## target more underquota
# define under quota spp and increase fishing on these. https://www.afma.gov.au/sites/default/files/semac_tac_recommendations_2019-20.pdf
# undercaught TAC is a performance indicator of the fishery - can be added to the socio-economic ones?
under<-c("macruronus novaezelandiae","nemadactylus macropterus","zeus faber","pristiophorus cirratus") # Jackass morwong is a bit funny as it's declining and there are no data for assessment. redfish?! recovery or undercaught? shawshrk is low values, not overfished
df_target_MoreUnderQuota<-as.data.frame(df_target_bmsy) %>%
mutate(fleet = rownames(df_target_bmsy)) %>%
gather(key = "species", value = "interaction", - fleet) %>%
mutate(interaction = ifelse(species %in% under & interaction > 0, interaction*5, interaction)) %>%
mutate(interaction = ifelse(interaction > 1, 1, interaction))
df_target_MoreUnderQuota<-acast(df_target_MoreUnderQuota, fleet ~ species)
######## target best
# a combination of the above scenarios
# df_target_best<-df_target_bmsy
####### runs
target_scenario = list(unfished = df_target_unfished, noCompetition = df_target_NoCompetition, fullCompetition = df_target_FullCompetition, statusQuo = df_target_bmsy, noBycatch = df_target_NoBycatch, MoreTarget = df_target_MoreTarget, MoreUnderQuota = df_target_MoreUnderQuota) # best = df_target_best)
params_scenario<-list()
sim_scenario<-list()
for(i in 1:length(target_scenario)){
params_scenario[[i]] <- MizerParams(df_param,
interaction = theta,
kappa = kappa,
kappa_ben = kappa_ben,
kappa_alg = kappa_alg,
w_pp_cutoff = w_pp_cutoff,# should be 'new' here but may not matter
min_w_bb = min_w_bb,
w_bb_cutoff = w_bb_cutoff,
fleetDynamics = TRUE,
selectivity_params = selectivity_params,
catchability = target_scenario[[i]],
target = target_scenario[[i]])
sim_scenario[[i]] <- project(params_scenario[[i]],
# t_max = nrow(price),
effort = 0,
dt = dt,
fleetDynamics = TRUE,
management = TRUE,
multiFleet = FALSE,
price = price_forward,
cost = cost_forward,
diet_steps = 0,
ke = ke, # should be calibrated here
initial_n = initial_n_scenario,
initial_n_pp = initial_n_pp_scenario,
initial_n_bb = initial_n_bb_scenario,
initial_effort = initial_effort_scenario,
scaling_price = scaling_price, # should be calibrated values here
Blevel_management = Blevel_management)
names(sim_scenario)[i]<-names(target_scenario)[i]
}
```
#-----------------------------------------
# scenarios management *skyp*
#----------------------------------------------
